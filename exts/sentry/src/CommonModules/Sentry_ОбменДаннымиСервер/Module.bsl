#Область ПрограммныйИнтерфейс

// Выполняет первое подключение (или переподключение) к Sentry.
// Создает настройки подключения, регламентное задание, группу и профиль доступа к подсистеме Sentry.
//
// Параметры:  
//  ИнтернетПротокол - Число - используемый интернет-протокол. Допустимые значения: 0 = https, 1 = http.
//  АдресСервиса - Строка - хост сервера, с которым осуществляется соединение.
//	Порт - Число  - порт сервера, с которым осуществляется соединение.
//	Ключ - Строка - уникальный идентификатор интеграции в сервисе для отправки запросов в Sentry. 
//	ПроектID - Строка - уникальный идентификатор проекта в сервисе для отправки запросов в Sentry. 
//	Отказ - Булево - Истина, если не удалось установить соединение.
//
Процедура ПервыйЗапуск(ЗащищенныйИнтернетПротокол, АдресСервиса, Порт, Ключ, ПроектID, Отказ = Ложь, ТекстОшибки = Неопределено, КодОтвета = 0) Экспорт 
	
	Заголовки = Новый Соответствие();
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("X-Sentry-Auth", СтрШаблон("Sentry sentry_version=7,sentry_client=sentry-curl/1.0,sentry_key=%1", Ключ));

	// TODO: Создать ресурс
	Ресурс = СтрШаблон("/api/%1/store/", ПроектID); 
	Тело = ПервыйЗапускСоздатьТестовоеСобытие();
	
	Ответ = ОтправитьЗапрос(АдресСервиса, Ресурс, Порт, ЗащищенныйИнтернетПротокол, "POST", Тело, Заголовки);
	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	КодОтвета = Ответ.КодСостояния;
	
	Если КодОтвета <> 200 Тогда
		Отказ = Истина;
		ТелоОтвета = ?(ЗначениеЗаполнено(ТелоОтвета), Символы.ПС + ТелоОтвета, "");

		ТекстОшибки = СтрШаблон(НСтр("ru = 'Отсутствует связь с сервером, код ответа: %1. %2'"), КодОтвета, ТелоОтвета);
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ТекстОшибки;
		Сообщение.Сообщить();

		ЗаписьЖурналаРегистрации("Sentry.ПервыйЗапуск", УровеньЖурналаРегистрации.Ошибка,,,ТекстОшибки);
	КонецЕсли;
	
КонецПроцедуры

Функция ПервыйЗапускСоздатьТестовоеСобытие()
	
	ПредставлениеИнформационнойБазы = Sentry_ОбменДаннымиПовтИсп.ПредставлениеИнформационнойБазы();

	// Формируем структуру события
	Событие = Новый Структура;
	//Событие.Вставить("event_id", EventID);
	TimeStamp = ТекущаяДата() - '19700101';
	Событие.Вставить("timestamp", TimeStamp);
	Событие.Вставить("platform", "other");
	Событие.Вставить("level", "info");
	Событие.Вставить("logger", "1c-platform");
	Событие.Вставить("server_name", ПредставлениеИнформационнойБазы.ИмяСервера);
	Событие.Вставить("release", Метаданные.Версия);
	Событие.Вставить("environment", "production");
	
	Событие.Вставить("dist", ПредставлениеИнформационнойБазы.ИмяИБНаСервере);
	
	// Message
	Событие.Вставить("message", "Тестовое событие первого запуска");
	
	// Конвертируем в JSON
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Событие);
	JSONСтрока = ЗаписьJSON.Закрыть();

	Возврат JSONСтрока;
	
КонецФункции

// Функция отправки события в Sentry (обновленная версия)
Процедура ОтправитьОшибкуВSentry(СтрокаЖурнала, ЗащищенныйИнтернетПротокол, АдресСервиса, Порт, Ключ, ПроектID) Экспорт
	
	Попытка
		
		Заголовки = Новый Соответствие();
		Заголовки.Вставить("Content-Type", "application/json");
		Заголовки.Вставить("X-Sentry-Auth", СтрШаблон("Sentry sentry_version=7,sentry_client=sentry-curl/1.0,sentry_key=%1", Ключ));
		
		Ресурс = СтрШаблон("/api/%1/store/", ПроектID); 
		Тело = СформироватьSentryEvent(СтрокаЖурнала);
		
		Ответ = ОтправитьЗапрос(АдресСервиса, Ресурс, Порт, ЗащищенныйИнтернетПротокол, "POST", Тело, Заголовки);
		ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
		КодОтвета = Ответ.КодСостояния;
		
		Если КодОтвета <> 200 Тогда
			ТелоОтвета = ?(ЗначениеЗаполнено(ТелоОтвета), Символы.ПС + ТелоОтвета, "");
			
			ТекстОшибки = СтрШаблон(НСтр("ru = 'Отсутствует связь с сервером, код ответа: %1. %2'"), КодОтвета, ТелоОтвета);
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = ТекстОшибки;
			Сообщение.Сообщить();
			
			ЗаписьЖурналаРегистрации("Sentry.ОтправитьОшибкуВSentry", УровеньЖурналаРегистрации.Ошибка,,,ТекстОшибки);
		КонецЕсли;
		
	Исключение
		// Логируем ошибку отправки, но не прерываем основной процесс
		ТекстОшибки = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации("Sentry.ОтправитьОшибкуВSentry", УровеньЖурналаРегистрации.Ошибка,,,"Не удалось отправить событие в Sentry: " + ТекстОшибки);
	КонецПопытки;
	
КонецПроцедуры


#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс
// Код процедур и функций
#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область СервисныеПроцедурыЗапросов

// Формирует и отправляет HTTP-запрос.
//
// Параметры:
//    Адрес		 - Строка - хост сервера, с которым осуществляется соединение.
//	  Порт		 - Число  - порт сервера, с которым осуществляется соединение.
//	  Метод		 - Строка - имя HTTP-метода.
//	  Токен		 - Строка - уникальный идентификатор интеграции в сервисе для отправки запросов в Sentry. 
//	  Тело		 - Строка - тело запроса в виде строки.
//	  Заголовки  - Соответствие - см. ЗаголовкиHTTPЗапроса().
//
// Возвращаемое значение:
//	HTTPОтвет
//
Функция ОтправитьЗапрос(Адрес, Ресурс, Порт, ЗащищенныйИнтернетПротокол, Метод, Тело = Неопределено, Заголовки = Неопределено) Экспорт 
	
	ИнтернетПрокси = Неопределено;
	
	ЗащищенноеСоединение = ?(ЗащищенныйИнтернетПротокол = Истина,
							 //ОбщегоНазначенияКлиентСервер.НовоеЗащищенноеСоединение(),
							 Новый ЗащищенноеСоединениеOpenSSL(неопределено, неопределено),
							 Неопределено);
	
	HTTPСоединение = Новый HTTPСоединение(Адрес, Порт, , , ИнтернетПрокси, 120, ЗащищенноеСоединение);
	HTTPЗапрос = Новый HTTPЗапрос(Ресурс); 
	
	HTTPЗапрос.Заголовки = Заголовки;
	
	Если ВРег(Метод) <> "GET" И Тело <> Неопределено Тогда
		HTTPЗапрос.УстановитьТелоИзСтроки(Тело, КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);
	КонецЕсли;
	
	Возврат HTTPСоединение.ВызватьHTTPМетод(Метод, HTTPЗапрос);
	
КонецФункции

#КонецОбласти



#Область ПодготовкаСообщенияВSentry 

// Функция парсинга стека вызовов из комментария журнала регистрации 1С
// Возвращает массив фреймов в формате Sentry
//
// Параметры:
//   ТекстКомментария - Строка - текст комментария из журнала регистрации
//
// Возвращаемое значение:
//   Массив структур - массив фреймов стека для Sentry
//
Функция СтекВызововИзКомментария(ТекстКомментария)
	
	// Паттерн для строк стека: |{Модуль(номер)}:вызов или {Модуль(номер)}:вызов
	// Обрабатываем строки, которые могут начинаться с | или без него
	Шаблон = "\|?\{([^}]+)\((\d+)\)\}:(.*)";
		
	Результат = Новый Массив;
	УникальныеФреймы = Новый Соответствие; // Для отслеживания дубликатов
	
	Если ПустаяСтрока(ТекстКомментария) Тогда
		Возврат Результат;
	КонецЕсли;
	
	СтрокиКомментария = СтрРазделить(ТекстКомментария, Символы.ПС, Ложь);
	
	Для Каждого СтрокаКомментария Из СтрокиКомментария Цикл
		
		СтрокаКомментария = СокрЛП(СтрокаКомментария);
		
		// Убираем ведущий символ | если есть
		Если Лев(СтрокаКомментария, 1) = "|" Тогда
			СтрокаКомментария = Сред(СтрокаКомментария, 2);
			СтрокаКомментария = СокрЛП(СтрокаКомментария);
		КонецЕсли;
		
		// Ищем строки стека вызовов (начинаются с {)
		Если Лев(СтрокаКомментария, 1) = "{" Тогда
			
			Совпадения = СтрНайтиВсеПоРегулярномуВыражению(СтрокаКомментария, Шаблон);
			
			Если Совпадения.Количество() > 0 Тогда
				
				Совпадение = Совпадения[0];
				Группы = Совпадение.ПолучитьГруппы();
				
				// Извлекаем данные
				МодульПолный = СокрЛП(Группы[0].Значение);  // например: "ОбщийМодуль.ОбменДанными.Модуль"
				НомерСтроки = Группы[1].Значение;
				КодВызова = СокрЛП(Группы[2].Значение);
				
				// Формируем уникальный ключ: модуль + строка
				УникальныйКлюч = МодульПолный + ":" + НомерСтроки;
				
				// Проверяем, не добавляли ли мы уже этот фрейм
				Если УникальныеФреймы[УникальныйКлюч] = Неопределено Тогда
					
					// Помечаем как добавленный
					УникальныеФреймы.Вставить(УникальныйКлюч, Истина);
					
					// Пытаемся извлечь имя функции из полного имени модуля
					ИмяФункции = ИзвлечьИмяФункцииИзМодуля(МодульПолный);
					
					// Формируем фрейм в формате Sentry
					Фрейм = Новый Структура;
					Фрейм.Вставить("filename", МодульПолный);        // Полный путь к модулю
					Фрейм.Вставить("function", ИмяФункции);          // Имя функции/метода
					
					// Путь к файлу в Git репозитории для определения автора
					ПутьВGit = ПреобразоватьМодуль1СВПутьGit(МодульПолный);
					Фрейм.Вставить("abs_path", ПутьВGit);
					
					// Преобразуем номер строки в число
					Попытка
						Фрейм.Вставить("lineno", Число(НомерСтроки));
					Исключение
						Фрейм.Вставить("lineno", 0);
					КонецПопытки;
					
					// Добавляем контекст - строку кода
					Если ЗначениеЗаполнено(КодВызова) Тогда
						Фрейм.Вставить("context_line", КодВызова);
					КонецЕсли;
					
					// Помечаем как код приложения (не системный)
					Фрейм.Вставить("in_app", Истина);
					
					// Добавляем модуль для группировки (опционально)
					ИмяМодуля = ИзвлечьИмяМодуля(МодульПолный);
					Если ЗначениеЗаполнено(ИмяМодуля) Тогда
						Фрейм.Вставить("module", ИмяМодуля);
					КонецЕсли;
					
					Результат.Вставить(0, Фрейм);
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
		
	Возврат Результат;
	
КонецФункции

// Извлекает имя функции из полного пути модуля
// Например: "ОбщийМодуль.Lamoda.Модуль" → "Lamoda"
Функция ИзвлечьИмяФункцииИзМодуля(МодульПолный)
	
	Если ПустаяСтрока(МодульПолный) Тогда
		Возврат МодульПолный;
	КонецЕсли;
	
	// Разбиваем по точкам
	Части = СтрРазделить(МодульПолный, ".", Ложь);
	
	Если Части.Количество() = 0 Тогда
		Возврат МодульПолный;
	КонецЕсли;
	
	// Для "ОбщийМодуль.Lamoda.Модуль" берем Lamoda (индекс 1)
	// Для "Обработка.ИмяОбработки.МодульОбъекта" берем ИмяОбработки (индекс 1)
	// Для других случаев берем последний элемент
	Если Части.Количество() >= 2 Тогда
		Возврат Части[1];
	Иначе
		Возврат Части[Части.Количество() - 1];
	КонецЕсли;
	
КонецФункции

// Извлекает короткое имя модуля для группировки
// Например: "ОбщийМодуль.Lamoda.Модуль" → "Lamoda"
Функция ИзвлечьИмяМодуля(МодульПолный)
	
	Если ПустаяСтрока(МодульПолный) Тогда
		Возврат "";
	КонецЕсли;
	
	// Разбиваем по точкам
	Части = СтрРазделить(МодульПолный, ".", Ложь);
	
	Если Части.Количество() >= 2 Тогда
		// Берем имя модуля (второй элемент)
		Возврат Части[1];
	ИначеЕсли Части.Количество() = 1 Тогда
		Возврат Части[0];
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Пример использования с интеграцией в отправку Sentry:

// Формирование JSON события для Sentry (используем новый парсер)
Функция СформироватьSentryEvent(СтрокаЖурнала) Экспорт
	
	ПредставлениеИнформационнойБазы = Sentry_ОбменДаннымиПовтИсп.ПредставлениеИнформационнойБазы();
	
	// Определяем уровень ошибки
	УровеньSentry = "error";
	Если СтрокаЖурнала.Уровень = УровеньЖурналаРегистрации.Предупреждение Тогда
		УровеньSentry = "warning";
	ИначеЕсли СтрокаЖурнала.Уровень = УровеньЖурналаРегистрации.Информация Тогда
		УровеньSentry = "info";
	ИначеЕсли СтрокаЖурнала.Уровень = УровеньЖурналаРегистрации.Примечание Тогда
		УровеньSentry = "note";
	КонецЕсли;
	
	// Парсим стек вызовов из комментария (используем новую функцию с регулярками)
	СтекВызовов = СтекВызововИзКомментария(СтрокаЖурнала.Комментарий);
	
	// Формируем структуру события
	Событие = Новый Структура;
	//Событие.Вставить("event_id", EventID);
	TimeStamp = УниверсальноеВремя(СтрокаЖурнала.Дата) - '19700101'; // Преобразуем в timestamp. Часовой пояс уже указывается в настройка профиля Sentry
	Событие.Вставить("timestamp", TimeStamp);
	Событие.Вставить("platform", "other");
	Событие.Вставить("level", УровеньSentry);
	Событие.Вставить("logger", "1c-platform");
	Событие.Вставить("server_name", СтрокаЖурнала.РабочийСервер);
	Событие.Вставить("release", Метаданные.Версия);
	Событие.Вставить("transaction", СтрокаЖурнала.Транзакция);
	Событие.Вставить("environment", "production");
	Событие.Вставить("dist", ПредставлениеИнформационнойБазы.ИмяИБНаСервере);
	Событие.Вставить("message", СтрокаЖурнала.Комментарий);
	
	// Exception с stacktrace
	Если СтекВызовов.Количество() > 0 Тогда
		СообщениеКраткое = ПолучитьКраткоеСообщение(СтрокаЖурнала.Комментарий);
		Exception = Новый Структура;
		Exception.Вставить("type", СтрокаЖурнала.ПредставлениеСобытия);
		Exception.Вставить("value", СообщениеКраткое);
		
		Stacktrace = Новый Структура;
		Stacktrace.Вставить("frames", СтекВызовов);
		Exception.Вставить("stacktrace", Stacktrace);
		
		Exceptions = Новый Массив;
		Exceptions.Добавить(Exception);
		
		ВложеннаяСтруктура = Новый Структура;
		ВложеннаяСтруктура.Вставить("values", Exceptions);
		Событие.Вставить("exception", ВложеннаяСтруктура);
	КонецЕсли;
	
	// User (отдельное поле верхнего уровня для отображения в интерфейсе Sentry)
	User = Новый Структура;
	Если ЗначениеЗаполнено(СтрокаЖурнала.ИмяПользователя) Тогда
		User.Вставить("id", Строка(СтрокаЖурнала.Пользователь));
		User.Вставить("username", Строка(СтрокаЖурнала.ИмяПользователя));
	КонецЕсли;
	Событие.Вставить("user", User);
	
	// Tags
	Tags = Новый Структура;
	Tags.Вставить("application", СтрокаЖурнала.ПредставлениеПриложения);
	Tags.Вставить("event_type", СтрокаЖурнала.ПредставлениеСобытия);
	Tags.Вставить("session", Строка(СтрокаЖурнала.Сеанс));
	Событие.Вставить("tags", Tags);
	
	// Extra context
	Extra = Новый Структура;
	Extra.Вставить("connection", СтрокаЖурнала.Соединение);
	Extra.Вставить("metadata", СтрокаЖурнала.Метаданные);
	//Extra.Вставить("full_comment", СтрокаЖурнала.Комментарий);
	Событие.Вставить("extra", Extra);
	
	Событие.Вставить("contexts", Новый Соответствие);
	
	Событие["contexts"].Вставить("device", Новый Соответствие);
	Событие["contexts"]["device"].вставить("type", "device");
	Событие["contexts"]["device"].вставить("name", СтрокаЖурнала.Компьютер);
	
	Событие["contexts"].Вставить("app", Новый Соответствие);
	Событие["contexts"]["app"].вставить("app_name", СтрокаЖурнала.ИмяПриложения);
	Событие["contexts"]["app"].вставить("build_type", СтрокаЖурнала.ПредставлениеПриложения);
	Событие["contexts"]["app"].вставить("app_version", Sentry_ОбменДаннымиПовтИсп.ВерсияПриложения());

	// Конвертируем в JSON
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Событие);
	JSONСтрока = ЗаписьJSON.Закрыть();
	
	Возврат JSONСтрока;
	
КонецФункции

// Преобразует имя модуля 1С в путь к файлу в Git репозитории (EDT структура)
//
// Параметры:
//  МодульИмя - Строка - имя модуля в формате 1С (например, "Обработка.Тест.МодульОбъекта")
//
// Возвращаемое значение:
//  Строка - путь к файлу в Git репозитории (например, "src/DataProcessors/Тест/Ext/ObjectModule.bsl")
//
Функция ПреобразоватьМодуль1СВПутьGit(МодульИмя)
	
	// Разбираем имя модуля
	ЧастиМодуля = СтрРазделить(МодульИмя, ".");
	
	Если ЧастиМодуля.Количество() < 2 Тогда
		
		Возврат МодульИмя; // Возвращаем как есть, если не удалось разобрать
		
	КонецЕсли;
	
	ТипОбъекта = ЧастиМодуля[0]; // "Обработка", "Документ", "Справочник", "ОбщийМодуль" и т.д.
	ИмяОбъекта = ЧастиМодуля[1]; // Имя объекта
	
	// Определяем папку в Git (EDT структура)
	ПапкаТипа = СопоставитьТипОбъектаСПапкойEDT(ТипОбъекта);
	
	// Особый случай для общих модулей
	Если ТипОбъекта = "ОбщийМодуль" Тогда
		
		Возврат СтрШаблон("src/CommonModules/%1/Ext/Module.bsl", ИмяОбъекта);
		
	КонецЕсли;
	
	// Определяем тип и путь к модулю
	ПутьКМодулю = "";
	
	Если ЧастиМодуля.Количество() >= 3 Тогда
		
		ТретьяЧасть = ЧастиМодуля[2];
		
		// Модули объекта или менеджера
		Если ТретьяЧасть = "МодульОбъекта" Тогда
			
			ПутьКМодулю = СтрШаблон("src/%1/%2/Ext/ObjectModule.bsl", ПапкаТипа, ИмяОбъекта);
			
		ИначеЕсли ТретьяЧасть = "МодульМенеджера" Тогда
			
			ПутьКМодулю = СтрШаблон("src/%1/%2/Ext/ManagerModule.bsl", ПапкаТипа, ИмяОбъекта);
			
		ИначеЕсли ТретьяЧасть = "Форма" ИЛИ ТретьяЧасть = "Forms" Тогда
			
			// Форма: Обработка.Тест.Форма.ИмяФормы.Форма
			Если ЧастиМодуля.Количество() >= 4 Тогда
				
				ИмяФормы = ЧастиМодуля[3];
				ПутьКМодулю = СтрШаблон("src/%1/%2/Forms/%3/Ext/Form/Module.bsl", ПапкаТипа, ИмяОбъекта, ИмяФормы);
				
			КонецЕсли;
			
		ИначеЕсли ТретьяЧасть = "Команда" ИЛИ ТретьяЧасть = "Commands" Тогда
			
			// Команда: Обработка.Тест.Команда.ИмяКоманды
			Если ЧастиМодуля.Количество() >= 4 Тогда
				
				ИмяКоманды = ЧастиМодуля[3];
				ПутьКМодулю = СтрШаблон("src/%1/%2/Commands/%3/Ext/CommandModule.bsl", ПапкаТипа, ИмяОбъекта, ИмяКоманды);
				
			КонецЕсли;
			
		Иначе
			
			// Неизвестный тип, возвращаем как есть
			Возврат МодульИмя;
			
		КонецЕсли;
		
	Иначе
		
		// Если только 2 части - это может быть модуль объекта или менеджера
		ПутьКМодулю = СтрШаблон("src/%1/%2/Ext/ObjectModule.bsl", ПапкаТипа, ИмяОбъекта);
		
	КонецЕсли;
	
	Возврат ПутьКМодулю;
	
КонецФункции

// Сопоставляет тип объекта 1С с папкой в Git репозитории (EDT структура)
//
// Параметры:
//  ТипОбъекта - Строка - тип объекта метаданных 1С
//
// Возвращаемое значение:
//  Строка - имя папки в Git репозитории
//
Функция СопоставитьТипОбъектаСПапкойEDT(ТипОбъекта)
	
	// Соответствие типов объектов 1С папкам в EDT
	Соответствие = Новый Соответствие;
	
	// Основные типы
	Соответствие.Вставить("Справочник", "Catalogs");
	Соответствие.Вставить("Документ", "Documents");
	Соответствие.Вставить("Обработка", "DataProcessors");
	Соответствие.Вставить("Отчет", "Reports");
	
	// Регистры
	Соответствие.Вставить("РегистрСведений", "InformationRegisters");
	Соответствие.Вставить("РегистрНакопления", "AccumulationRegisters");
	Соответствие.Вставить("РегистрБухгалтерии", "AccountingRegisters");
	Соответствие.Вставить("РегистрРасчета", "CalculationRegisters");
	
	// Планы
	Соответствие.Вставить("ПланВидовХарактеристик", "ChartsOfCharacteristicTypes");
	Соответствие.Вставить("ПланСчетов", "ChartsOfAccounts");
	Соответствие.Вставить("ПланВидовРасчета", "ChartsOfCalculationTypes");
	Соответствие.Вставить("ПланОбмена", "ExchangePlans");
	
	// Бизнес-процессы и задачи
	Соответствие.Вставить("БизнесПроцесс", "BusinessProcesses");
	Соответствие.Вставить("Задача", "Tasks");
	
	// Прочие
	Соответствие.Вставить("ОбщийМодуль", "CommonModules");
	Соответствие.Вставить("Константа", "Constants");
	Соответствие.Вставить("ЖурналДокументов", "DocumentJournals");
	Соответствие.Вставить("Перечисление", "Enums");
	Соответствие.Вставить("ВнешнийИсточникДанных", "ExternalDataSources");
	Соответствие.Вставить("HTTPСервис", "HTTPServices");
	Соответствие.Вставить("WebСервис", "WebServices");
	Соответствие.Вставить("WSСсылка", "WSReferences");
	
	ПапкаТипа = Соответствие.Получить(ТипОбъекта);
	
	Если ПапкаТипа = Неопределено Тогда
		
		// Если не нашли точное соответствие, возвращаем сам тип
		Возврат ТипОбъекта;
		
	КонецЕсли;
	
	Возврат ПапкаТипа;
	
КонецФункции

// Получение краткого сообщения об ошибке
Функция ПолучитьКраткоеСообщение(Комментарий)
	
	Если Не ЗначениеЗаполнено(Комментарий) Тогда
		Возврат "Ошибка без описания";
	КонецЕсли;
	
	// Берем первую значимую строку
	Строки = СтрРазделить(Комментарий, Символы.ПС, Ложь);
	
	Для Каждого Строка Из Строки Цикл
		СтрокаОбрезанная = СокрЛП(Строка);
		
		// Убираем ведущий |
		Если Лев(СтрокаОбрезанная, 1) = "|" Тогда
			СтрокаОбрезанная = СокрЛП(Сред(СтрокаОбрезанная, 2));
		КонецЕсли;
		
		// Пропускаем строки стека вызовов и служебные строки
		Если Не ПустаяСтрока(СтрокаОбрезанная) 
			И Лев(СтрокаОбрезанная, 1) <> "{"
			И Найти(СтрокаОбрезанная, "по причине:") = 0
			И Найти(СтрокаОбрезанная, "[Ошибка") = 0 Тогда
			Возврат СтрокаОбрезанная;
		КонецЕсли;
	КонецЦикла;
	
	// Если не нашли, возвращаем первую непустую строку
	Если Строки.Количество() > 0 Тогда
		Возврат СокрЛП(Строки[0]);
	КонецЕсли;
	
	Возврат "Ошибка";
	
КонецФункции

#КонецОбласти

#КонецОбласти